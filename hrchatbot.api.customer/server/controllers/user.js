'use strict';
import model from '../models';
import authManager from '../auth/authManager';

var crypto = require('crypto');

const Sequelize = require('sequelize');
const { User } = model;

// used to generate salt for the hashing algorithm
let generateRandomStringSequence = function(length){
    return Users.generateHashSalt(length);
};

/**
 * Function that produces a hashing object that holds the provided salt and hashed password
 * @param password is the string password provided by the user
 * @param salt is the salt string used in tha hashing algorithm
 * @return {{salt: *, hashedPassword: string}} object that holds salt and hashed password
 */
let hashing = function(password, salt){
    let hash = crypto.createHmac('sha512', salt);
    hash.update(password);
    let val = hash.digest('hex');
    return {
        salt: salt,
        hashedPassword: val
    };
};

/**
 * Function that returns the 'hashing' which is the object that holds the salt and hashed
 * password strings
 * @param password string of user entered password
 * @return {{salt, hashedPassword}} contains salt string and hashedPassword
 */
function saltHashPassword(password) {
    let salt = generateRandomStringSequence(16);
    return hashing(password, salt);
}

class Users {

    /**
     * Function that generates the string that returns the salt object used for hashing
     * @param length is the size of the generated salt
     * @return {string} generated bytes for the salt
     */
    static generateHashSalt (length){
        return crypto.randomBytes(Math.ceil(length/2))
            .toString('hex')
            .slice(0, length)
    }

    /**
     * Function used for comparing the passwords that are provided through parameters
     * @param storedHashedPassword the password stored in the database
     * @param storedSalt the salt stored in the database
     * @param isUserAdmin boolean value of if the user is admin or not
     * @param userPassword string password passed by the user from the application
     * @return {boolean} true if passwords are the same and false if they don't match
     */
    static passwordComparison(storedHashedPassword, storedSalt, isUserAdmin, userPassword) {
        const { hashedPassword } = hashing(userPassword, storedSalt);
        if(storedHashedPassword === hashedPassword){
            // user is authenticated
            return true;
        }
    }

    /**
     * Return all users from the database
     * @param req request object
     * @param res response object
     * @return {Promise<T | never>}
     */
    static getAllUsers(req, res) {
        return User
            .findAll()
            .then(users =>
                {
                    // if there are no users in the database error is returned along with
                    // 404 - resource not found code
                    if(users != null && users.length > 0) res.status(200).send({
                        success: true,
                        message: 'Users fetched',
                        users
                    });
                    else res.status(404).send({
                        success: false,
                        error: 'There are no users in the database'
                    });
                }
            );
    }
    // No validation needed

    //TODO: figure out how to allow initial setting of the password when user still doesn't
    // have auth_token generated?
    static resetUserPassword(req, res) {
        // auth_token is sent over from the application in the request body and new password is provided
        const { auth_token, new_password } = req.body;
        User.findOne({
            where: {auth_token: auth_token},
            attributes: ['name', 'email']
        }).then(userData => {
            if(userData !== null) {
                const salt = userData.get('salt');
                const { hashedPassword } = hashing(new_password, salt);
                userData.set({
                    password: hashedPassword
                });
                userData.save();
                res.status(200).send({
                    message: 'Password has been reset',
                    data: userData
                })
            }
        })
        // .catch(Sequelize.ValidationError, function (err) {
        //     console.log(`Got an error :"${err}"`);
        //     res.status(500).send({
        //         success: false,
        //         message: err.message
        //     })
        // })
    }


    /**
     * Updating user with the sent data
     * @param req request object
     * @param res response object
     * @return {Promise<T | never>}
     */
    static updateUser(req, res) {
        const { userId } = req.params;
        const { name, email, password, salt, auth_token, auth_token_valid_to } = req.body;
        return User
            .findByPk(userId)
            .then(user => {
                user.update({
                    name: name || user.name,
                    email: email || user.email,
                    password: password || user.password,
                    salt: salt || user.salt,
                    auth_token: auth_token || user.auth_token,
                    auth_token_valid_to: auth_token_valid_to || user.auth_token_valid_to
                })
                .then(updatedUser => {
                    res.status.code(200).send({
                        message: 'User updated successfully',
                        data: {
                            name: updatedUser.name,
                            email: updatedUser.email,
                            password: updatedUser.password,
                            salt: updatedUser.salt,
                            auth_token: updatedUser.auth_token,
                            auth_token_valid_to: updatedUser.auth_token_valid_to
                        }
                    })
                })
                .catch(error => res.status(400).send(error))
            })
            .catch(error => res.status(400).send(error))
    }

    /**
     * Removing user from the database based on the sent user ID
     * @param req request object
     * @param res response object
     * @return {Promise<T | never>}
     */
    static removeUser(req, res) {
        const { userId } = req.params;
        return User
            .destroy({
                where: {
                    id: userId
                }
            })
            .then( user => res.status(202).send({
                message: `User ${user.username} has been removed.`,
                user
            }))
    }

    /**
     * Return a user that is found under the given ID
     * @param req request object
     * @param res response object
     * @return {Promise<T | never>}
     */
    static getUser(req, res) {
        const { userId } = req.params;
        return User
            .findOne({
                where: {
                    id: userId
                },
                attributes: [
                    'name',
                    'email'
                ]
            })
            .then(user =>
                {
                    // if there is no user under the provided ID the server sends
                    // back 404 error - resource not found
                    if(user != null) res.status(200).send(user);
                    else res.status(404).send({
                        error: 'No user under this ID has been found'
                    });
                }
                )
            .catch(function (err) {
                console.log(err.message);
            })
    }


    /**
     * Login function which takes in the email and password and authenticates the user
     * @param req
     * @param res
     */
    static login(req, res) {
        const { email, password } = req.body;
        User.findOne({ where: {email: email} }).then(userData => {
            if(userData !== null) {
                authManager.authenticateUser(userData, email, password);
                res.status(200).send(userData);
            }
        })
    }

    /**
     * Registers a user by email and username, it doesn't create token, for that user needs to log in in order
     * to generate them.
     * Can be used with a provided password and without the password
     * @param req request object that holds all the needed data
     * @param res response object
     * @return {Promise<T | never | Error>}
     */
    static signUp(req, res) {
        const { name, username, email, auth_token, auth_token_valid_to } = req.body;
        let { password } = req.body;
        let generated_salt = generateRandomStringSequence(16);
        if (password !== null && password !== undefined && password.length !== 0){
            const { salt, hashedPassword } = saltHashPassword(password);
            generated_salt = salt;
            password = hashedPassword;
        }else
            password = "resetpassword";
        return User
            .create({
                name,
                username,
                email,
                password,
                salt: generated_salt,
                auth_token,
                auth_token_valid_to
            })
            .then(userData => res.status(201).send({
                success: true,
                message: 'User successfully created',
                userData
            }))
            .catch(Sequelize.ValidationError, function (err) {
                console.log(`Got an errror :"${err}"`);
                res.status(500).send({
                    success: false,
                    message: err.message
                })
            })
    }
}

export default Users;
