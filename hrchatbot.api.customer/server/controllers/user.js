'use strict';
import model from '../models';
import authManager from '../auth/authManager';

const mailingService = require('./../mail_service/mailing_service');
const crypto = require('crypto');

const Sequelize = require('sequelize');
const { User } = model;

// variable that holds generated salt for the hashing algorithm
let generateRandomStringSequence = function(length){
    return Users.generateHashSalt(length);
};

/**
 * Function that produces a hashing object that holds the provided salt and hashed password
 * @param password is the string password provided by the user
 * @param salt is the salt string used in tha hashing algorithm
 * @return {{salt: *, hashedPassword: string}} object that holds salt and hashed password
 */
let hashing = function(password, salt){
    let hash = crypto.createHmac('sha512', salt);
    hash.update(password);
    let val = hash.digest('hex');
    return {
        salt: salt,
        hashedPassword: val
    };
};

/**
 * Function that returns the 'hashing' which is the object that holds the salt and hashed
 * password strings
 * @param password string of user entered password
 * @return {{salt, hashedPassword}} contains salt string and hashedPassword
 */
function saltHashPassword(password) {
    let salt = generateRandomStringSequence(16);
    return hashing(password, salt);
}

/**
 * Function that validates user password when trying to reset password
 * It requires at least 8 characters of length, at least 1 letter and at least 2 numbers
 * No special characters are allowed
 * @param password string value of password
 * @return {*} object that holds the validity and message of the validation function
 */
function validatePassword(password) {
    let atLeastTwoDigits = new RegExp("[0-9].*[0-9]");
    let atLeastOneCharacter = new RegExp("[a-zA-Z]");
    let onlyEightCharactersAndDigits = new RegExp("^[0-9a-zA-Z]{8,}$"); // no special chars

    if (atLeastTwoDigits.test(password) &&
        atLeastOneCharacter.test(password) &&
        onlyEightCharactersAndDigits.test(password)) {
        return {
            valid: true,
            message: 'Password is valid'
        };
    } else {
        return {
            valid: false,
            message: 'Password must be 8 digits long and it must include at least 2 numbers ' +
                'and cannot contain any special characters'
        };
    }
}

/**
 * Generates integer from the current date, ex. 23.09.1994. at 17:42 -> 199409231742
 * @return {number} integer representation of the date
 */
function getCurrentDateInteger() {
    const date = new Date();
    const year = date.getFullYear();
    const month = ("0" + (date.getMonth() + 1)).slice(-2);
    const dateDay = ("0" + date.getDate()).slice(-2);
    const hours = ("0" + date.getHours()).slice(-2);
    const minutes = ("0" + date.getMinutes()).slice(-2);
    return parseInt(year+month+dateDay+hours+minutes);
}


class Users {

    /**
     * Function that generates the string that returns the salt object used for hashing
     * @param length is the size of the generated salt
     * @return {string} generated bytes for the salt
     */
    static generateHashSalt (length){
        return crypto.randomBytes(Math.ceil(length/2))
            .toString('hex')
            .slice(0, length)
    }

    /**
     * Function used for comparing the passwords that are provided through parameters
     * @param storedHashedPassword the password stored in the database
     * @param storedSalt the salt stored in the database
     * @param userPassword string password passed by the user from the application
     * @return {boolean} true if passwords are the same and false if they don't match
     */
    static passwordComparison(storedHashedPassword, storedSalt, userPassword) {
        const { hashedPassword } = hashing(userPassword, storedSalt);
        return storedHashedPassword === hashedPassword;
    }

    /**
     * Return true or false depending on if the user is administrator
     * @param req request object
     * @param res response object
     * @return {Promise<T | never>}
     */
    static isAdministrator(req, res) {
        const { auth_token } = req.body;
        return User
            .findOne({
                where: {
                    auth_token: auth_token
                },
                attributes: [
                    'isAdmin',
                    'auth_token_valid_to'
                ]
            })
            .then(user => {
                    // if there is no user under the provided token the server sends
                    // back 404 error - resource not found
                    if(user !== undefined && user != null) {
                        // Checking if the token is still valid
                        if (parseInt(user.get('auth_token_valid_to')) > getCurrentDateInteger()) {
                            res.status(200).send({
                                success: true,
                                message: 'User admin status returned',
                                data: {
                                    isAdmin: user.get('isAdmin')
                                }
                            });
                        } else {
                            res.status(500).send({
                                success: false,
                                message: 'Token date is not valid'
                            });
                        } // invalid token else
                    } else {
                        res.status(404).send({
                            success: false,
                            message: 'No user has been found'
                        });
                    } // user not found by that token else
                }) // ending then
            .catch(function (err) {
                res.status(500).send({
                    success: false,
                    message: err.message
                });
            }) // ending catch
    }

    /**
     * Return all users from the database
     * @param req request object
     * @param res response object
     * @return {Promise<T | never>}
     */
    static getAllUsers(req, res) {
        return User
            .findAll()
            .then(users =>
                {
                    // if there are no users in the database error is returned along with
                    // 404 - resource not found code
                    if(users != null && users.length > 0) res.status(200).send({
                        success: true,
                        message: 'Users fetched',
                        users
                    });
                    else res.status(404).send({
                        success: false,
                        message: 'There are no users in the database'
                    });
                }
            );
    }

    /**
     * Reset password functionality that takes in the value for new password and auth_token
     * stored on the user side that is used for the authentication
     * @param req request object holding new password and authentication token
     * @param res response object that is used to return data to the user
     */
    static resetUserPassword(req, res) {
        // auth_token is sent over from the application in the request body and new password is provided
        const { auth_token, password } = req.body;
        const { valid, message } = validatePassword(password);
        // find by auth_token as it is unique
        if(valid === true){
            User.findOne({
                where: {
                    auth_token: auth_token
                },
                attributes: [
                    'id',
                    'name',
                    'email',
                    'salt',
                    'auth_token_valid_to'
                ]
            })
            .then(userData => {
                // checking if there is a user by that authentication token
                if(userData !== undefined && userData !== null) {
                    // get stored salt and the date to which the token is valid
                    const salt = userData.get('salt');
                    const tokenDate = userData.get('auth_token_valid_to');
                    // checks if the token is still valid
                    if (tokenDate > getCurrentDateInteger()) {
                        const { hashedPassword } = hashing(password, salt);

                        // changing password
                        userData.set({
                            password: hashedPassword
                        });
                        // storing the updated object to the DB
                        userData.save();

                        res.status(200).send({
                            success: true,
                            message: 'Password has been reset',
                            data: userData
                        })
                    } else {
                        res.status(500).send({
                            success: false,
                            message: "Token has expired"
                        })
                    }
                } else {
                    res.status(500).send({
                        success: false,
                        message: "User under the token doesn't exist"
                    })
                }
            })
        } else {
            res.status(500).send({
                success: valid,
                message: message
            })
        }
    }

    /**
     * Updating user with the sent data
     * @param req request object
     * @param res response object
     * @return {Promise<T | never>}
     */
    static updateUser(req, res) {
        // TODO: create a similar function that will do this over the user email?
        const { userId } = req.params;
         // TODO: keep password and salt so that we can allow the admin to reset user password
        const { name, email, password, salt, isAdmin } = req.body;
        return User
            .findByPk(userId)
            .then(user => {
                if (user !== undefined && user !== null) {
                    user.update({
                        name: name || user.name,
                        email: email || user.email,
                        //password: password || user.password,
                        isAdmin: isAdmin || user.isAdmin
                    })
                    .then(updatedUser => {
                        res.status(200).send({
                            success: true,
                            message: 'User updated successfully',
                            data: {
                                name: updatedUser.name,
                                email: updatedUser.email,
                                //password: updatedUser.password,
                                isAdmin: updatedUser.isAdmin
                            }
                        })
                    })
                    .catch(error => res.status(400).send({
                        success: false,
                        message: error.message
                    }))
                } else {
                    res.status(404).send({
                        success: false,
                        message: `There is no user under the given userId`
                    })
                }
            })
            .catch(error =>{
                res.status(400).send({
                    success: false,
                    message: error.message
                });
            }
            )
    }

    /**
     * Removing user from the database based on the sent user ID
     * @param req request object
     * @param res response object
     * @return {Promise<T | never>}
     */
    static deleteUser(req, res) {
        const { userId } = req.params;
        return User
            .destroy({
                where: {
                    id: userId
                }
            })
            .then( user => {
                    if (user !== undefined && user !== null) {
                        res.status(202).send({
                        success: true,
                        message: `User ${user.username} has been removed.`,
                        user })
                    } else {
                        res.status(404).send({
                            success: false,
                            message: `There is no user under the given userId`
                        })
                    }
            })
            .catch(function (err) {
                res.status(500).send({
                    success: false,
                    message: err.message
                });
            })
    }

    /**
     * Fetch name, email address and admin status of the user that is found under the provided ID
     * @param req request object that holds the user ID primary key parameter sent from the client via the URL
     * @param res response object that holds name, email and admin status data about the user
     * @return {Promise<T | never>}
     */
    static getUser(req, res) {
        const { userId } = req.params;
        return User
            .findOne({
                where: {
                    id: userId
                },
                attributes: [
                    'name',
                    'email',
                    'isAdmin'
                ]
            })
            .then(user => {
                if(user !== undefined && user != null) res.status(200).send({
                    success: true,
                    message: 'User found',
                    data: user
                });
                // if there is no user under the provided ID the server sends
                // back 404 error - resource not found
                else res.status(404).send({
                    success: false,
                    message: 'No user under this ID has been found'
                });
            })
            .catch(function (err) {
                res.status(500).send({
                    success: false,
                    message: err.message
                });
            })
    }


    /**
     * Login function which takes in the email and password and authenticates the user
     * @param req request object holding email and password that are passed to the server from the client
     * @param res response object that holds all the data for the found user
     */
    static login(req, res) {
        const { email, password } = req.body;
        User.findOne({
            where: {
                email: email
            }})
            .then( async userData => {
                if (userData !== null && userData !== undefined) {
                    // forward userData that holds all the data for the returned user (salt and hashed pw are gathered from it)
                    // provide auth manager with email and password to be compared
                    const {success, message} = await authManager.authenticateUser(userData, email, password);
                    if ((/true/i).test(success)) {
                        // returning only token and admin status
                        let data = {
                            auth_token: userData.get('auth_token'),
                            isAdmin: userData.get('isAdmin')
                        };
                        res.status(200).send({
                            success: true,
                            message: 'User has been successfully logged in',
                            data: data
                        });
                    } else {
                        throw new Error(message);
                    }
                } else {
                    // if there is no user by the defined email we throw an error in order to return error message
                    throw new Sequelize.ValidationError('User credentials are not correct');
                }
            })
            .catch(Sequelize.ValidationError, function (err) {
                res.status(500).send({
                    success: false,
                    message: err.message
                })
            })
            .catch(function (err) {
                res.status(500).send({
                    success: false,
                    message: err.message
                })
            })
    }

    /**
     * Registers a user by email and username, it doesn't create token, for that user needs to log in in order
     * to generate them.
     * @param req request object that has email, name and admin status
     * @param res response object used to send the data back to the user site
     * @return {Promise<T | never | Error>}
     */
    static signUp(req, res) {
        // pull all the data from the body provided by the query
        console.log(req.body);
        const { name, email, isAdmin, auth_token, auth_token_valid_to } = req.body;
        console.log(`Data is ${name}, ${email} and ${isAdmin}`);
        let generated_salt;
        let hashed_password;

        // TODO: we can add code here if we want to allow admins to create account with them setting the password initially

        let password = generateRandomStringSequence(10);
        const { salt, hashedPassword } = saltHashPassword(password);
        generated_salt = salt;
        hashed_password = hashedPassword;


        return User
            .create({
                name: name,
                email: email,
                password: hashed_password,
                salt: generated_salt,
                isAdmin: isAdmin,
                auth_token: auth_token,
                auth_token_valid_to: auth_token_valid_to
            })
            .then(userData =>
                res.status(201).send({
                success: true,
                message: 'User successfully created',
                userData
                }),
                mailingService.send(
                    email,
                    "Successful Registration",
                    '',
                    `<h2>Welcome to our HRChatbot service <b>${name}</b></h2><br>` +
                    `You have been successfully registered with this email address for our chatbot service 
                    and your password is <b>${password}</b>, it an be changed once You have
                    logged into the application.`)
            )
            .catch(Sequelize.ValidationError, function (err) {
                console.log(`Got an error :"${err}"`);
                res.status(500).send({
                    success: false,
                    message: err.message
                })
            })
    }
}

export default Users;
